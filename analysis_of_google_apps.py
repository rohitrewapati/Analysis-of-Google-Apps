# -*- coding: utf-8 -*-
"""Analysis of Google Apps.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CrKm4hC2jMQecXYnya15z2rM-8AvNZiu

# Google Playstore Analysis

Google Play store is a digital distribution service operated and developed by Google. It serves as the official app store on the Android operating system. The aim of this project is to analyse the apps which are available on Google play store.
The dataset is downloded from kaggle.It consists of apps along with their category, reviews, ratings and many more things.
In this project we analyse the performance of the apps using numpy, pandas, matplotlib and seaborn, and find out many interesting things.
"""

project_name = "Google Playstore Analysis"

!pip install jovian --upgrade -q

import jovian

jovian.commit(project=project_name)

"""# Import the libraries

To perform analysis on data, we have to import certain libraries, which are as follows-
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd               #used for reading the dataset
import numpy as np                #used for numeric calculations
import matplotlib.pyplot as plt   #matplotlib and seaborn, both are used for visualization
import seaborn as sns
# %matplotlib inline

"""## Reading the data

It is important to understand the data before analysis, like finding how many rows and columns is present, the type of the columns etc. By this we came to know about insights of the data.
"""

#Read the data using pandas with an build in function "read_csv" followed by the name or path of the file.
dataset=pd.read_csv("googleplaystore.csv")
#Below command results in 1st five rows of the data
dataset.head()

#Pd.read_csv stored the data into dataframe, we can check it by using the type function.
type(dataset)

#Shape is used to find the total number of rows and columns
dataset.shape

#This command gives all the names of the columns
dataset.columns

#This command gives the statistical computation of numeric columns
dataset.describe()

"""Note that by describe() function, we came to know about that the dataset has only one numeric column i.e Rating."""

#This command gives the total number of unique values in each column
dataset.nunique()

#This command gives the basic information of each column related to their type,null values and total number of rows and columns.
dataset.info()

"""From this we came to know about that the columns- rating, type, content rating, current version and android version has null values.

# Data Preparation and Cleaning

It is an important step before analysis. In this stage, we find how many null values are present, how to remove unwanted data and other things which is needed to be clean.
"""

#This command gives the total null values present in each column.
dataset.isnull().sum()

#This command gives the total null values present in dataset.
dataset.isnull().sum().sum()

#The visual representation of null values using seaborn.
sns.heatmap(dataset.isnull())

#Boxplot shows the distribution/range of the numerical data.
dataset.boxplot()

"""But note that here is one point which is not in the expected range, so we have to remove that from the dataset.
This point is known as outlier.
"""

#Here we find how many points are above the range.
dataset[dataset.Rating>5]

"""We got only one outlier. Now we have to remove it from dataset."""

#To remove a row, drop() is used. Inplace is used to permanentaly remove that row from dataset.
dataset.drop([10472],inplace=True)

#Checking whether that row is now present or not.
dataset[10470:10475]

"""See that 10472 row is not present in dataset.By this method, we remove the outlier."""

#Again plotting boxplot to completing understand it.
dataset.boxplot()

"""Now see that all the values are in proper range."""

import jovian

jovian.commit(files=["googleplaystore.csv"])

"""# Data Manipulation

It is a part of data cleaning. In this, we fill the null values.

### 1. Numerical column

From info() function, we know that we have only one numeric column i.e Rating. We fill the null values of that column with median of that column.
"""

#Here we define a function median by which we fill the null value with median
def median(col):
    return col.fillna(col.median())

#We fill the null value of rating column with median
dataset.Rating=dataset["Rating"].transform(median)

dataset.isnull().sum()

"""Now the rating column has no null values.

### 2. Categorical column

Now we have three columns which have null values. We fill this with mode of that column.
"""

#Here we find what is the mode of particular column i.e which value occurs the most.
print(dataset["Type"].mode())
print(dataset["Current Ver"].mode())
print(dataset["Android Ver"].mode())

#We fill the null values by mode which is computed above.
dataset["Type"].fillna(str(dataset['Type'].mode().values[0]),inplace=True)
dataset["Current Ver"].fillna(str(dataset['Current Ver'].mode().values[0]),inplace=True)
dataset["Android Ver"].fillna(str(dataset['Android Ver'].mode().values[0]),inplace=True)

dataset.isnull().sum()

"""By this we have no null values present in the dataset.

Now looking at the dataset, by the column names we understand that price and reviews column also come under the numeric column but in datset they have the type of object i.e string. So we have to convert them into numeric column.
"""

#We take the price column, apply a lambda function to replace $ with an space and then changed it to float type.
dataset["Price"]=dataset["Price"].apply(lambda x:str(x).replace("$","") if "$" in str(x) else str(x))
dataset["Price"]=dataset["Price"].apply(lambda x:float(x))

#We take review column and used an inbuild function pd.to_numeric to convert the column into numeric.
dataset["Reviews"]=pd.to_numeric(dataset["Reviews"],errors="coerce")

#Look at the changes in price and review column.
dataset.head()

#Again checking the type of columns.
dataset.info()

"""See that now we have three numeric columns i.e Rating, Price and Reviews."""

jovian.commit(files=["googleplaystore.csv"])

"""## Exploratory Analysis and Visualization

In this step, we put our data into visualization, as to see the clear picture of the dataset. This process is important as it provides more insights from the data.
"""

dataset.describe()

"""After performing data manipulation, now we have three numerical columns.

## 1. Histogram- A histogram is an approximate representation of the distribution of                                              numerical data.
"""

dataset.hist("Rating")

"""By this visualization, we can say that 4.5 is given to many apps.

## 2. Boxplot- A boxplot, also called a box and whisker plot, is a way to show the spread and centers of a data set.
"""

dataset.boxplot()

"""## 3. Distplot- The  distplot shows the distribution of a univariate set of observations."""

sns.set_style("whitegrid")
sns.distplot(dataset["Rating"],bins=20)

"""By distplot we came to know that mostly rating are lies between 4-5

## 4. Jointplot- Jointplot allows you to basically match up two distplots for bivariate data.
"""

#Here we saw relationship between rating and reviews
sns.set_style("darkgrid")
sns.jointplot(x='Rating',y='Reviews',data=dataset,kind='scatter')

"""## 5. Pairplot- Pairplot will plot pairwise relationships across an entire dataframe (for the numerical columns) and supports a color hue argument (for categorical columns)."""

g=sns.pairplot(dataset,hue="Category",palette='coolwarm')
g.map_diag(plt.hist)

"""## 6. Countplot- This is essentially the same as barplot except the estimator is explicitly counting the number of occurrences. Which is why we only pass the x value."""

#Here we saw what value in content rating column occurs most.
plt.figure(figsize=(10,4))
sns.countplot("Content Rating", data=dataset,palette='rainbow')

"""As in this plot, we saw mostly content rating or apps is everyone."""

import jovian

jovian.commit(files=["googleplaystore.csv"])

"""## Grouping the apps using category column"""

grp=dataset.groupby("Category")
grp

d=grp.describe()
d

"""## Which category has maximum number of apps?"""

#Total number of apps in each category
a=d["Rating"]["count"]
a

a.max()

#Plotting the result
plt.figure(figsize=(16,5))
plt.plot(a,"r+",color="b")
plt.xticks(rotation=90)
plt.title("Number of Apps")
plt.xlabel("Category")
plt.ylabel("Number")
plt.show()

"""Maximum numbers of app is in Family category.

## Which category has minimum number of apps?
"""

a.min()

"""Minimum numbers of app is in beauty category.

## Which category has received more ratings?
"""

#We aggregate the rating column with its mean, in simple words we find average rating of each app, thus able to computer the high rating
r=grp['Rating'].agg(np.mean)
print(r)

r.max()     #maximum rating

#Plotting the result
plt.figure(figsize=(16,5))
plt.plot(r,"r*",color="b")
plt.xticks(rotation=90)
plt.title("Category wise rating")
plt.xlabel("Category")
plt.ylabel("Ratings")
plt.show()

"""This shows that events category has received more rating.

## Which category has more reviews?
"""

#Here we aggregate the review column by its mean value
Rev=grp["Reviews"].agg(np.mean)
print(Rev)

Rev.max()

#Plotting the result
plt.figure(figsize=(16,5))
plt.plot(Rev,"r--",color="g")
plt.xticks(rotation=90)
plt.title("Category wise review")
plt.xlabel("Category")
plt.ylabel("Reviews")
plt.show()

"""By this graph we can say that both communication and social apps have almost same number of reviews.

## What is the price of each category?Which category has highest price?
"""

#Here we aggregate price column by its sum
p=grp["Price"].agg(np.sum)
print(p)

p.max()        #Highest price

#Plotting the result
plt.figure(figsize=(16,5))
plt.plot(p,"g.-",color="g")
plt.xticks(rotation=90)
plt.title("Category wise price")
plt.xlabel("Category")
plt.ylabel("Price")
plt.show()

"""The graph shows that Finance category has highest price of their apps."""

import jovian

jovian.commit(files=["googleplaystore.csv"])

"""## Conclusion

By this analysis, we saw so many insights of the Google Apps. We came to know about differnt types of apps, their ratings, reviews, price and all the other information related to apps which we never saw before this project.  this type of projects are very useful to gain more information and to became more familar with them.
I select this dataset as it seems interesting to me and related to our needs as we install apps from Google Play Store.
"""

import jovian

jovian.commit(files=["googleplaystore.csv"])

